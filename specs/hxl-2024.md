# HXL.2024

## Introduction

**HXL** is a data interchange format similar to JSON or YAML, but sporting
additional features which are more dynamic in nature, such as inheritance
and references.

It was originally designed to function as data storage for a game engine, containing
descriptions about objects, materials and lights.

## Design goal

The design goal is to make HXL:

- Useful
- Streamlined
- Easy to parse

## Lexical structure

### Character set

HXL's structures can be covered in ASCII range, but implementations
must support **Unicode** to provide cross-platform and cross-language flexibility
in the data.

### Basic syntax

An HXL file consists of one or more **nodes**.
Every node consists of zero, one or more **properties**.

An example from a game engine would be:

````text
<Player> MainCharacter
    name: "John Doe"
    health: 100
````

- ``<Player>`` is the **node type**. This is a required declaration, which eases deserialization
  when the data is interpreted.
- ``MainCharacter`` is the **node name**.
- ``name`` and ``health`` are **node properties**. ``name`` is a string, ``health`` is an integer.

Every node must have a type and name. They can, theoretically, have any number
of properties, although they must satisfy a schema.

## Data types

### String

String values must be defined between quotes.

````text
<Player> MainCharacter
    name: "John Doe"
````

Please reference the **Rules** section for behavior-specific definitions.

### Integer

````text
<Player> MainCharacter
    int: 45
````

Values can be negative or positive.

Scientific notation, hexadecimal and similar forms are NOT supported.

### Floating-point values

````text
<Player> MainCharacter
    float: -10.5
````

Values can be negative or positive.

Scientific notation, hexadecimal and similar forms are NOT supported.

### Reference

A property can be a reference to another node.

To indicate a reference, the property name must be suffixed by ``&``.

The value of the property is the exact name of the node.

````text
<Player> MainCharacter
    age: 45
    
<Enemy> Monster
    target&: MainCharacter
````

### Array

Arrays are denoted by suffixing the property name with ``[]``.

Values are declared between ``{`` and ``}``, and are separated by comma (``,``).

````text
<Cube3D> CubeA
    position[] = { 2, 4, -2 }
````

As of 2024, only strings, integer and floating-point values are allowed as array values.

## Features

### Inheritance

Inheritance means a node will copy all the properties from another node,
and override the properties explicitly defined.

Example:

````text
<Enemy> MonsterOne
    health: 100
    position[]: { 4, 0, 4 }
    
<Enemy> MonsterTwo <= MonsterOne
    position[]: { 8, 0 , 8 }
````

In this example, ``MonsterTwo`` implicitly copies ``health`` (as 100).

As of 2024 specification, a node can only inherit ONE node.

### Comments

Any text following ``#`` on any line should be ignored, with the only
exception being when the ``#`` is within a string literal.

## Syntax rules

Each rule has their own section below.
Most rules must return an error code, when the criteria aren't met,
and that will be listed as "Error code: ``HXL_ERROR_CODE``".

> In implementations, it's recommended to reference the rule name (e.g. ``GEN.001``)
> at the point where it is implemented, and as well in unit tests.

### GEN.001: No content

There MUST be content in an HXL source, even if it's just an empty line.

Error code: ``HXL_EMPTY``

### GEN.002: End of file must be empty line

An HXL file MUST end with an empty line.

Error code: ``HXL_INVALID_EOF``

### GEN.003: Ignoring ``\r``

The presence of ``\r`` is allowed in HXL sources, but MUST be completely ignored in
interpretation. Whenever we speak about "new line", it is ALWAYS and ONLY denoted
by ``\n``.

### NODE.001: Node type and name

A node declaration requires a node type and a name,
provided on the form: ``<Type> Name``

Error code: ``HXL_INVALID_NODE_FORM``

Valid example:

````text
<Player> MainCharacter
````

### NODE.002:

There MUST be a single whitespace (``\s``) between the type and the name.

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
<Player> MainCharacter
````

Invalid:

````text
<Player>MainCharacter
````

### NODE.003: Tab before property

Every node property must be preceded by EXACTLY one tab (``\t``)

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
<NodeType> NodeName
    key: 10
````

Invalid:

````text
<NodeType> NodeName
key: 10
````

### NODE.004: First ``:`` separates key and value

The first colon (``:``) marks where the key-value pair splits.
The first part is the key, the second is the value.

Error code: ``HXL_INVALID_PROPERTY_FORM``

Valid:

````text
<NodeType> NodeName
    key: "value"
````

Invalid:

````text
<NodeType> NodeName:
    key = "value"
````

### NODE.005: Whitespace between key and ``:``

Any type of whitespace between property name and ``:`` is NOT allowed.

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
<NodeType> NodeName
    key: "value"
````

Invalid:

````text
<NodeType> NodeName
    key : "value"
````

### NODE.006: Whitespace after ``:`` 

A single whitespace ``\s`` MUST succeed ``:`` and precede the value.

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
<NodeType> NodeName
    key: "value"
````

Invalid:

````text
<NodeType> NodeName
    key:"value"
````

### NODE.007: Value part non-string literals

Everything after the ``:`` (except for the initial, required whitespace) MUST
be considered part of the value, unless a ``#`` outside a string literal is encountered.

That means that reading a value ends at either ``\n`` (new line) or ``#`` outside a
string literal (comment)

### NODE.008: Value part for string literals

In the case of string literals, the value is everything two non-escaped
quotation marks.

Whitespace between ending quote and comment is to be ignored.

### NODE.009: Whitespace between end-of-string and comment

EXACTLY one whitespace (``\s``) must be placed between the end-of-string quotation mark
and the beginning of a comment.

Valid:

````text
  key: "value" # Comment
````

Invalid:

````text
  key: "value"# Comment
````

### STR.001: Escaping characters

Character escapes are preceded backslash, for example ``\"``. Any character can be escaped.

### STR.002: ``#`` within string literal

Within a string literal ``#`` MUST NOT be interpreted as the beginning of a comment.

This means that:

````text
<NodeType> NodeName
    key: "Hello # World" # Comment here
````

In this snippet, the value of ``key`` is ``Hello # World``

### STR.003: ``:`` within string literal

Within a string literal ``:`` MUST NOT cause tokenization error, and must be considered part of the string.

Error code: ``HXL_UNEXPECTED_TOKEN``

Valid:

````text
<NodeType> NodeName
    value: "Hello : World"
````

Invalid:

````text
<NodeType> NodeName
    value:: "Hello world"
````

### STR.004: ``\n`` within string literal

New-line ``\n`` is NOT allowed within a string literal.

Error code: ``HXL_ILLEGAL_STRING``

Invalid:

````text
  key: "hello
  world"
````

Also invalid:

````text
  key: "Hello\nworld"
````

### INT.001: Integer notation

Integer values MUST be given on the form ``-x`` or ``x`` (example: ``-5`` or ``11``)

As of _HXL.2024_, scientific, hexadecimal and other numeric notations are NOT supported.

Valid:

````text
  value: -5
````

### FLOAT.001: Floating-point value notation

Float values are ONLY valid when a decimal point and at least one decimal are present.
  (example: ``-5.05``)

Error code: ``HXL_ILLEGAL_FLOAT``

As of 2024, scientific, hexadecimal and other numeric notations are NOT supported.

### FLOAT.002: Casting from integer notation not allowed

Values on the form ``-5`` or ``5`` MUST NOT be automatically cast to float-pointer value.

Error code: ``HXL_ILLEGAL_FLOAT``

This validation can usually not be done until validating against a schema.


### ARR.001: Whitespacing around array brackets

Array values MUST be encapsulated between ``{`` and ``}`` with EXACTLY
one whitespace character (``\s``) separating the braces from the values.

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
  arr[]: { 1, 2, 3 }
````

Invalid:

````text
  arr[]: {1, 2, 3}
````

### ARR.002: Whitespacing between array values

Array values MUST have EXACTLY one whitespace character (``\s``) preceding it,
and be separated by a comma (``,``). Example: ``{ 2, 3, 4 }``

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
  arr[] = { 1, 2, 3 }
````

Invalid:

````text
  arr[] = { 1,2,3 }
````

### ARR.003: Mixed types in arrays

Arrays values MUST be of identical type.

Error code: ``HXL_ARRAY_MIXED_TYPES``

Valid:

````text
  arr[] = { 1, 2, 3 }
````

````text
  arr[] = { -0.5, 1.3, 2.0 }
````

````text
  arr[] = { "a", "b", "c" }
````

Invalid:

````text
  arr[] = { 1, 2.0, 3 }
````

````text
  arr[] = { "Hello", 2, 3 }
````

### ARR.004: Supported types in array value

Array values MUST be either string, integer or floating-point values.

Nested arrays and references are NOT supported.

Error code: ``HXL_ARRAY_UNKNOWN_TYPE``

### REF.001: 

Property key must be suffixed with ``&``.

### REF.002: Whitespacing around ``&``

There MUST NOT be any whitespace surrounding the ``&``.

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
  ref&: NodeName
````

Invalid:

````text
  ref &: NodeName
````

### CMT.001: Scanning comments

Any text following ``#`` MUST be ignored, EXCEPT when the character is found inside a string literal.

Example:

````text
    key: "Hello # World" # Comment
````

In the above, ``key``'s value is ``Hello # World``.

`` # Comment`` SHOULD be ignored.

### CMT.002: Whitespacing around ``#``

There MUST be exactly one whitespace ``\s`` on each side of ``#``.

Error code: ``HXL_ILLEGAL_WHITESPACE``

Valid:

````text
  key: "value" # Comment
````

Invalid:

````text
  key: "value" #Comment
````

````text
  key: "value"# Comment
````

### CMT.003: Empty comments

Comment must not be empty, this is to be considered a parsing error

Error: ``HXL_ILLEGAL_COMMENT``

Invalid:

````text
  key: "value" #
````

### INHR.001: Whitespace around ``<=``

- There MUST be exactly ONE whitespace character (``\s``) on each side of the ``<=`` token.

## Structural rules

- [``HXL_NODE_REFERENCE_NOT_FOUND``] Referenced nodes MUST exist.
- [``HXL_NODE_REFERENCE_NOT_FOUND``] Referenced nodes MUST be declared earlier in the HXL file
- [``HXL_CIRCULAR_NODE_REFERENCE``] Circular references MUST cause an error.
- [``HXL_ILLEGAL_REFERENCE``] A node CANNOT reference itself
- [``HXL_INHERIT_DIFF_TYPES``] An inherited node MUST have the EXACT same node type.
- [``HXL_NODE_REFERENCE_NOT_FOUND``] An inherited node MUST exist.
- [``HXL_NODE_REFERENCE_NOT_FOUND``] An inherited node MUST be declared earlier in the file.
- [``HXL_ILLEGAL_INHERITANCE``] A node CANNOT inherit itself.
- [``HXL_NON_UNIQUE_NODE``] Node names MUST be unique.
- [``HXL_NON_UNIQUE_PROPERTY``] A node's properties MUST be unique.

> Names of nodes and properties are to be treated as case-sensitive.

## Schematic rules

You can read more about the schema under **Implementation nodes**

- [``HXL_UNKNOWN_NODE_TYPE``] When a node type is not part of the schema
- [``HXL_ILLEGAL_DATA_TYPE``] When the value of a property doesn't match the schema
- [``HXL_REQUIRED_PROPERTY_NOT_FOUND``] Required node property not found
- [``HXL_UNKNOWN_PROPERTY``] A property NOT found in the schema was provided

### Name validation

| Subject        | Regular expression      | Example            | Error code                   |
|----------------|-------------------------|--------------------|------------------------------|
| Node data type | ``([A-Z][a-z]+){1,}``   | ``NodeType``       | ``HXL_INVALID_NODE_TYPE``    |
| Node name      | ``([A-Z][a-zA-Z0-9]+)`` | ``MyNode3D``       | ``HXL_INVALID_NODE_NAME``    |
| Property key   | ``[a-z][a-z_]+``        | ``albedo_texture`` | ``HXL_INVALID_PROPERTY_KEY`` |

## Implementation notes

### Schema

Implementations should provide a schema which outlines:

- Supported node types
- Supported properties on a per node type basis
- The data type of each property
- Whether a data type is required
- (Optional) Default values for properties

### Pipeline

The recommended pipeline is:

- Tokenization
- Grammar validation
- Pre-schema validation
- Schema validation
- Translate to language-specific objects

**Tokenization** is the process of scanning the file, essentially by moving
a cursor over every character. During this process, you build tens, hundreds or
thousands of tokens.

Example, in the following:

`````text
<NodeType> NodeName <= ParentNode
`````

It could be tokenized as:

- ``<`` (Delimiter)
- ``NodeType`` (Identifier)
- ``>`` (Delimiter)
- ``NodeName`` (Identifier)
- ``<=`` (Delimiter)
- ``ParentNode`` (Identifier)

In the **grammar validation** you verify the order the tokens are provided
in. Building on the example above, we would expect an identifier to follow
the ``<`` delimiter. If that isn't the case, we encounter "an unexpected token."

In the **pre-schema validation**, you verify structures prior to using the
schema. This, for example, verifying that an array doesn't have mixed types
or verifying that references exist.

In the **schema validation** stage, you hold the structure up
against the schema. Here you verify that node types are correct, that
required properties exist, that unrecognized properties are caught, etc.

In the final stage, **translation to language-specific objects**,
the results are provided in objects which are readable by the implementation
language. This could be structs, classes or something else.

For C++, it could be a struct, in PHP an array with nested associative arrays.
This step might be more difficult in language which have limited reflection
capabilities.

### Other notes

It's recommended to design your implementation such that you support
multiple specifications, and the client can select which one
they adhere to.

It's also recommended that implementations which are to be used across
different projects, such as generalized libraries for HXL, provide a
way to dynamically select which features to allow. Not all of HXL's features
are fit for every kind of project.

Node types, node names and properties are case-sensitive.

## Error handling

When implementing HXL, you should provide these error codes to make sure
implementations are streamlined.

### Tokenization and grammar validation errors

| Error code                    | Error code | Description                                                         |
|-------------------------------|------------|---------------------------------------------------------------------|
| ``HXL_UNEXPECTED_TOKEN``      | ``5``      | When invalid characters are found in the initial tokenization.      |
| ``HXL_ILLEGAL_WHITESPACE``    | ``20``     | Wrong type of whitespace, or disallowed omission.                   |
| ``HXL_INVALID_NODE_FORM``     | ``25``     | A node is not specified on the correct form with a type and a name. |
| ``HXL_INVALID_PROPERTY_FORM`` | ``24``     | A line where a property is expected, does not include a ``:``       |
| ``HXL_INVALID_EOF``           | ``15``     | An HXL file must end with a empty line.                             |
| ``HXL_EMPTY``                 | ``10``     | The HXL source is empty.                                            |
| ``HXL_ILLEGAL_COMMENT``       | ``40``     | Comment is incorrectly formed.                                      |

### Pre-schema validation errors

Validation that must be carried out prior to validating the values against the schema.

| Error code                       | Error code | Description                                                                                                                                                       |
|----------------------------------|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ``HXL_ARRAY_MIXED_TYPES``        | ``200``    | Mixed data types in an array. Example: ``{ "Hello", 2, 3 }``                                                                                                      |
| ``HXL_ARRAY_UNKNOWN_TYPE``       | ``201``    | When anything other than string, integer or floating-point values are found in an array                                                                           |
| ``HXL_NODE_REFERENCE_NOT_FOUND`` | ``230``    | When a referenced node hasn't been defined at an earlier point in the HXL file.                                                                                   |
| ``HXL_CIRCULAR_NODE_REFERENCE``  | ``231``    | When node A references B, which then references A. This is automatically prevented if properly implemented that a referenced node MUST exist earlier in the file. |
| ``HXL_INHERIT_DIFF_TYPES``       | ``250``    | The inherited node is of a different type than the child node.                                                                                                    |
| ``HXL_ILLEGAL_INHERITANCE``      | ``251``    | When a node attempts to inherit itself.                                                                                                                           |
| ``HXL_ILLEGAL_REFERENCE``        | ``232``    | When a node property attempts to reference the node itself.                                                                                                       |
| ``HXL_INVALID_NODE_TYPE``        | ``300``    | The node type in ``<NodeType>`` is doesn't adhere to the regular expression.                                                                                      |
| ``HXL_INVALID_NODE_NAME``        | ``301``    | The node name doesn't adhere to the corresponding regular expression.                                                                                             |
| ``HXL_INVALID_PROPERTY_KEY``     | ``302``    | The property key doesn't adhere to the regular expression.                                                                                                        |
| ``HXL_ILLEGAL_FLOAT``            | ``400``    | The format of the floating-point value is not allowed (most likely given as integer)                                                                              |
| ``HXL_ILLEGAL_STRING``           | ``420``    | The string contains illegal characters, such as ``\n``.                                                                                                           |
| ``HXL_NON_UNIQUE_NODE``          | ``500``    | When a node name is used 2+ times.                                                                                                                                |
| ``HXL_NON_UNIQUE_PROPERTY``      | ``510``    | When a node contains 2+ properties with identical keys.                                                                                                           |

### Schema validation errors

When validating a schema, these error codes must be used:

| Error code                          | Error code | Description                                                 |
|-------------------------------------|------------|-------------------------------------------------------------|
| ``HXL_UNKNOWN_NODE_TYPE``           | ``800``    | The node type is not found in the schema.                   |
| ``HXL_ILLEGAL_DATA_TYPE``           | ``830``    | Schema expects one data type, but another is provided.      |
| ``HXL_REQUIRED_PROPERTY_NOT_FOUND`` | ``900``    | A property required in the schema is not found on the node. |
| ``HXL_UNKNOWN_PROPERTY``            | ``910``    | A property not declared in the schema is found on the node. |
